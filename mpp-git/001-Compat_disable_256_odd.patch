From 7d39aba9d2869c8a263e8527a92a34668bf9c94b Mon Sep 17 00:00:00 2001
From: Herman Chen <herman.chen@rock-chips.com>
Date: Sun, 08 Oct 2023 18:14:09 +0800
Subject: [PATCH] feat[compat]: Add no-256-odd-align compat config

Signed-off-by: Herman Chen <herman.chen@rock-chips.com>
Change-Id: I3eddf36ebce83aa75fa144227c67cc949e0b67b3
---

diff --git a/inc/mpp_compat.h b/inc/mpp_compat.h
index 22a3f17..d8263b0 100644
--- a/inc/mpp_compat.h
+++ b/inc/mpp_compat.h
@@ -24,6 +24,7 @@
     MPP_COMPAT_INC_FBC_BUF_SIZE,
     MPP_COMPAT_ENC_ASYNC_INPUT,
     MPP_COMPAT_DEC_FBC_HDR_256_ODD,
+    MPP_COMPAT_DEC_NFBC_NO_256_ODD,
     MPP_COMPAT_BUTT,
 } MppCompatId;
 
diff --git a/mpp/hal/rkdec/h264d/hal_h264d_rkv_reg.c b/mpp/hal/rkdec/h264d/hal_h264d_rkv_reg.c
index d0cee5f..0de583d 100644
--- a/mpp/hal/rkdec/h264d/hal_h264d_rkv_reg.c
+++ b/mpp/hal/rkdec/h264d/hal_h264d_rkv_reg.c
@@ -26,6 +26,7 @@
 #include "mpp_mem.h"
 #include "mpp_common.h"
 #include "mpp_bitput.h"
+#include "mpp_compat_impl.h"
 
 #include "hal_h264d_global.h"
 #include "hal_h264d_rkv_reg.h"
@@ -875,7 +876,9 @@
         if (fmt == MPP_FMT_YUV422SP) {
             mpp_slots_set_prop(p_hal->frame_slots, SLOTS_LEN_ALIGN, rkv_len_align_422);
         }
-        if (imgwidth > 1920 || imgheight > 1088) {
+        if (MPP_FRAME_FMT_IS_FBC(fmt)) {
+            mpp_err_f("rkv not support FBC\n");
+        } else if ((imgwidth > 1920 || imgheight > 1088) && !(*compat_ext_non_fbc_no_256_odd)) {
             mpp_slots_set_prop(p_hal->frame_slots, SLOTS_HOR_ALIGN, rkv_hor_align_256_odds);
         }
         break;
diff --git a/mpp/hal/rkdec/h264d/hal_h264d_vdpu34x.c b/mpp/hal/rkdec/h264d/hal_h264d_vdpu34x.c
index 7e95de0..ee2a0ee 100644
--- a/mpp/hal/rkdec/h264d/hal_h264d_vdpu34x.c
+++ b/mpp/hal/rkdec/h264d/hal_h264d_vdpu34x.c
@@ -27,6 +27,7 @@
 #include "mpp_bitput.h"
 
 #include "mpp_device.h"
+#include "mpp_compat_impl.h"
 
 #include "hal_h264d_global.h"
 #include "hal_h264d_vdpu34x.h"
@@ -1205,7 +1206,7 @@
         }
         if (MPP_FRAME_FMT_IS_FBC(fmt)) {
             vdpu34x_afbc_align_calc(p_hal->frame_slots, (MppFrame)param, 16);
-        } else if (imgwidth > 1920 || imgheight > 1088) {
+        } else if ((imgwidth > 1920 || imgheight > 1088) && !(*compat_ext_non_fbc_no_256_odd)) {
             mpp_slots_set_prop(p_hal->frame_slots, SLOTS_HOR_ALIGN, rkv_hor_align_256_odds);
         }
         break;
diff --git a/mpp/hal/rkdec/h264d/hal_h264d_vdpu382.c b/mpp/hal/rkdec/h264d/hal_h264d_vdpu382.c
index 4be70d1..710c9b7 100644
--- a/mpp/hal/rkdec/h264d/hal_h264d_vdpu382.c
+++ b/mpp/hal/rkdec/h264d/hal_h264d_vdpu382.c
@@ -29,6 +29,7 @@
 
 #include "mpp_device.h"
 #include "mpp_frame_impl.h"
+#include "mpp_compat_impl.h"
 
 #include "hal_h264d_global.h"
 #include "hal_h264d_vdpu382.h"
@@ -1339,7 +1340,7 @@
         }
         if (MPP_FRAME_FMT_IS_FBC(fmt)) {
             vdpu382_afbc_align_calc(p_hal->frame_slots, (MppFrame)param, 16);
-        } else if (imgwidth > 1920 || imgheight > 1088) {
+        } else if ((imgwidth > 1920 || imgheight > 1088) && !(*compat_ext_non_fbc_no_256_odd)) {
             mpp_slots_set_prop(p_hal->frame_slots, SLOTS_HOR_ALIGN, rkv_hor_align_256_odds);
         }
         break;
diff --git a/mpp/hal/rkdec/h265d/hal_h265d_com.c b/mpp/hal/rkdec/h265d/hal_h265d_com.c
index 1a12ff6..d7e8db7 100644
--- a/mpp/hal/rkdec/h265d/hal_h265d_com.c
+++ b/mpp/hal/rkdec/h265d/hal_h265d_com.c
@@ -22,6 +22,7 @@
 #include "mpp_common.h"
 #include "mpp_bitread.h"
 #include "mpp_bitput.h"
+#include "mpp_compat_impl.h"
 
 #include "hal_h265d_debug.h"
 #include "hal_h265d_ctx.h"
@@ -87,6 +88,9 @@
 
 RK_U32 hevc_hor_align(RK_U32 val)
 {
+    if (compat_ext_non_fbc_no_256_odd)
+        return MPP_ALIGN(val, 8);
+
     return MPP_ALIGN(val, 256) | 256;
 }
 
diff --git a/mpp/hal/rkdec/vp9d/hal_vp9d_com.c b/mpp/hal/rkdec/vp9d/hal_vp9d_com.c
index 571cccb..eacd11c 100644
--- a/mpp/hal/rkdec/vp9d/hal_vp9d_com.c
+++ b/mpp/hal/rkdec/vp9d/hal_vp9d_com.c
@@ -18,6 +18,7 @@
 
 #include "mpp_mem.h"
 #include "mpp_bitput.h"
+#include "mpp_compat_impl.h"
 
 #include "vp9d_syntax.h"
 #include "hal_vp9d_com.h"
@@ -996,6 +997,9 @@
 
 RK_U32 vp9_hor_align(RK_U32 val)
 {
+    if (compat_ext_non_fbc_no_256_odd)
+        return MPP_ALIGN(val, 64);
+
     return MPP_ALIGN(val, 256) | 256;
 }
 
diff --git a/osal/inc/mpp_compat_impl.h b/osal/inc/mpp_compat_impl.h
index 1725ce4..6cf1ce4 100644
--- a/osal/inc/mpp_compat_impl.h
+++ b/osal/inc/mpp_compat_impl.h
@@ -22,5 +22,6 @@
 extern RK_S32 *compat_ext_fbc_buf_size;
 extern RK_S32 *compat_ext_async_input;
 extern RK_S32 *compat_ext_fbc_hdr_256_odd;
+extern RK_S32 *compat_ext_non_fbc_no_256_odd;
 
 #endif /*__MPP_COMPAT_IMPL_H__*/
diff --git a/osal/mpp_compat.cpp b/osal/mpp_compat.cpp
index 6967f3b..2f0d58d 100644
--- a/osal/mpp_compat.cpp
+++ b/osal/mpp_compat.cpp
@@ -56,11 +56,20 @@
         "set decoder fbc header stride to 256 odd align",
         NULL,
     },
+    {
+        MPP_COMPAT_DEC_NFBC_NO_256_ODD,
+        MPP_COMPAT_BOOL,
+        0,
+        0,
+        "set decoder non-fbc mode stride not 256 odd align",
+        NULL,
+    },
 };
 
 RK_S32 *compat_ext_fbc_buf_size = &compats[MPP_COMPAT_INC_FBC_BUF_SIZE].value_usr;
 RK_S32 *compat_ext_async_input  = &compats[MPP_COMPAT_ENC_ASYNC_INPUT].value_usr;
 RK_S32 *compat_ext_fbc_hdr_256_odd  = &compats[MPP_COMPAT_DEC_FBC_HDR_256_ODD].value_usr;
+RK_S32 *compat_ext_non_fbc_no_256_odd  = &compats[MPP_COMPAT_DEC_NFBC_NO_256_ODD].value_usr;
 
 MppCompat *mpp_compat_query(void)
 {
